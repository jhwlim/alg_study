- (200) 자료구조1


#10828 : 스택
- 성공 (1회)
- 접근방법 : 스택
	- 직접 스택에 대한 클래스 및 메서드 구현


#9093 : 단어뒤집기
- 성공 (3회 이상) ~ 다른사람 코드 참고함.
- 접근방법 : 
	- 입력받은 문자열을 공백을 기준으로 문자열 배열에 저장하고,
	- 문자열 배열을 인덱스를 거꾸로해서 for문을 이용하여 접근하고, 새로운 문자열 변수에 저장한다.

- 어려웠던 점 : 시간 초과
- 원인 : 이중 for문 내부에서 System.out.print() 반복적으로 수행
- 해결방법 : 뒤집은 단어를 저장하는 문자열 변수를 통해서 for문 내부에서 한번만 System.out.print()를 수행함.
- 배운점 : System.out.print() 는 실행시간 관점에서 효율적이지 못하기 때문에, 사용횟수를 최소화하고, 출력 횟수가 많다면, BufferedWriter 클래스를 사용할 것.


#9012 : 괄호
- 성공 (1회)
- 접근방법 : 
	- cnt변수를 선언하고, '(' 가 들어오면 +1, ')'이 들어오면 -1을 한다. 
	- 중간에 0보다 작아진다면, ')'가 더 들어왔다는 것을 의미하기 때문에 NO를 출력한다. 
	- 마지막 cnt의 값이 0이 아닌 경우도, 균형이 안맞다는 것을 의미하므로 NO를 출력한다.


#1874 : 스택 수열
- 성공 (1회)
- 접근방법 : 스택
	- 문제 : n을 입력 → 1~n 사이의 숫자 배열을 입력
	- 1부터 스택에 순차적으로 push (+)
	- 입력된 배열의 요소를 순차적으로 확인할 때, 스택의 Top과 같아진다면 pop (-)
	- 스택에 입력된 숫자가 n 보다 커지면 NO를 출력함.


#1406 : 에디터
- 성공 (3회 이상)
- 접근방법 : 
	(1) 문자열 접근 : 시간초과 - 특정 인덱스의 삽입과 삭제는 시간 복잡도 관점에서 O(n) 
	(2) 스택 : 스택 2개를 이용하여 커서가 왼쪽일때와 오른쪽일때를 구분함.
- 어려웠던 점 : 시간초과
- 원인 : (2)번 방법으로 접근해도 처음에는 계속 시간초과였음. 이유는 Scanner와 System.out.print() 때문인 것으로 보임.
- 해결방법 : BufferedReader와 BufferedWriter를 사용
- 배운점 : Scanner와 System.out.print는 편리하지만 실행시간 관점에서 매우 비효율적인 것으로 보이면, BufferedReader와 BufferedWriter 클래스를 사용하자


#10845 : 큐
- 성공 (2회)
- 접근방법 : 큐
	- 직접 큐에 대한 클래스와 메서드 구현


#1158 : 요세푸스 문제
- 성공 (3회)
- 접근방법 : 큐
	- 정수 n과 k 입력
	- 1~n 까지 큐에 인큐
	- k번째 제거 : (k-1)회 디큐 & 인큐 -> 디큐하고, 디큐한 값을 리스트에 저장한다.


#11866 : 덱 
- 성공 (1회)
- 접근방법 : 리스트
	- 리스트 2개를 이용하여 front와 back을 구분함.

